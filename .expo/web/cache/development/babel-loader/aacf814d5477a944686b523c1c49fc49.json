{"ast":null,"code":"\"use strict\";\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from \"react\";\nimport View from \"react-native-web/dist/exports/View\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport var swipeDirections = {\n  SWIPE_UP: \"SWIPE_UP\",\n  SWIPE_DOWN: \"SWIPE_DOWN\",\n  SWIPE_LEFT: \"SWIPE_LEFT\",\n  SWIPE_RIGHT: \"SWIPE_RIGHT\"\n};\nvar swipeConfig = {\n  velocityThreshold: 0.3,\n  directionalOffsetThreshold: 80,\n  gestureIsClickThreshold: 5\n};\n\nfunction isValidSwipe(velocity, velocityThreshold, directionalOffset, directionalOffsetThreshold) {\n  return Math.abs(velocity) > velocityThreshold && Math.abs(directionalOffset) < directionalOffsetThreshold;\n}\n\nvar GestureRecognizer = function (_Component) {\n  _inherits(GestureRecognizer, _Component);\n\n  var _super = _createSuper(GestureRecognizer);\n\n  function GestureRecognizer(props, context) {\n    var _this;\n\n    _classCallCheck(this, GestureRecognizer);\n\n    _this = _super.call(this, props, context);\n    _this.swipeConfig = _extends(swipeConfig, props.config);\n\n    var responderEnd = _this._handlePanResponderEnd.bind(_assertThisInitialized(_this));\n\n    var shouldSetResponder = _this._handleShouldSetPanResponder.bind(_assertThisInitialized(_this));\n\n    _this._panResponder = PanResponder.create({\n      onStartShouldSetPanResponder: shouldSetResponder,\n      onMoveShouldSetPanResponder: shouldSetResponder,\n      onPanResponderRelease: responderEnd,\n      onPanResponderTerminate: responderEnd\n    });\n    return _this;\n  }\n\n  _createClass(GestureRecognizer, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.props.config !== prevProps.config) {\n        this.swipeConfig = _extends(swipeConfig, this.props.config);\n      }\n    }\n  }, {\n    key: \"_handleShouldSetPanResponder\",\n    value: function _handleShouldSetPanResponder(evt, gestureState) {\n      return evt.nativeEvent.touches.length === 1 && !this._gestureIsClick(gestureState);\n    }\n  }, {\n    key: \"_gestureIsClick\",\n    value: function _gestureIsClick(gestureState) {\n      return Math.abs(gestureState.dx) < swipeConfig.gestureIsClickThreshold && Math.abs(gestureState.dy) < swipeConfig.gestureIsClickThreshold;\n    }\n  }, {\n    key: \"_handlePanResponderEnd\",\n    value: function _handlePanResponderEnd(evt, gestureState) {\n      var swipeDirection = this._getSwipeDirection(gestureState);\n\n      this._triggerSwipeHandlers(swipeDirection, gestureState);\n    }\n  }, {\n    key: \"_triggerSwipeHandlers\",\n    value: function _triggerSwipeHandlers(swipeDirection, gestureState) {\n      var _this$props = this.props,\n          onSwipe = _this$props.onSwipe,\n          onSwipeUp = _this$props.onSwipeUp,\n          onSwipeDown = _this$props.onSwipeDown,\n          onSwipeLeft = _this$props.onSwipeLeft,\n          onSwipeRight = _this$props.onSwipeRight;\n      var SWIPE_LEFT = swipeDirections.SWIPE_LEFT,\n          SWIPE_RIGHT = swipeDirections.SWIPE_RIGHT,\n          SWIPE_UP = swipeDirections.SWIPE_UP,\n          SWIPE_DOWN = swipeDirections.SWIPE_DOWN;\n      onSwipe && onSwipe(swipeDirection, gestureState);\n\n      switch (swipeDirection) {\n        case SWIPE_LEFT:\n          onSwipeLeft && onSwipeLeft(gestureState);\n          break;\n\n        case SWIPE_RIGHT:\n          onSwipeRight && onSwipeRight(gestureState);\n          break;\n\n        case SWIPE_UP:\n          onSwipeUp && onSwipeUp(gestureState);\n          break;\n\n        case SWIPE_DOWN:\n          onSwipeDown && onSwipeDown(gestureState);\n          break;\n      }\n    }\n  }, {\n    key: \"_getSwipeDirection\",\n    value: function _getSwipeDirection(gestureState) {\n      var SWIPE_LEFT = swipeDirections.SWIPE_LEFT,\n          SWIPE_RIGHT = swipeDirections.SWIPE_RIGHT,\n          SWIPE_UP = swipeDirections.SWIPE_UP,\n          SWIPE_DOWN = swipeDirections.SWIPE_DOWN;\n      var dx = gestureState.dx,\n          dy = gestureState.dy;\n\n      if (this._isValidHorizontalSwipe(gestureState)) {\n        return dx > 0 ? SWIPE_RIGHT : SWIPE_LEFT;\n      } else if (this._isValidVerticalSwipe(gestureState)) {\n        return dy > 0 ? SWIPE_DOWN : SWIPE_UP;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_isValidHorizontalSwipe\",\n    value: function _isValidHorizontalSwipe(gestureState) {\n      var vx = gestureState.vx,\n          dy = gestureState.dy;\n      var _this$swipeConfig = this.swipeConfig,\n          velocityThreshold = _this$swipeConfig.velocityThreshold,\n          directionalOffsetThreshold = _this$swipeConfig.directionalOffsetThreshold;\n      return isValidSwipe(vx, velocityThreshold, dy, directionalOffsetThreshold);\n    }\n  }, {\n    key: \"_isValidVerticalSwipe\",\n    value: function _isValidVerticalSwipe(gestureState) {\n      var vy = gestureState.vy,\n          dx = gestureState.dx;\n      var _this$swipeConfig2 = this.swipeConfig,\n          velocityThreshold = _this$swipeConfig2.velocityThreshold,\n          directionalOffsetThreshold = _this$swipeConfig2.directionalOffsetThreshold;\n      return isValidSwipe(vy, velocityThreshold, dx, directionalOffsetThreshold);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return _jsx(View, _objectSpread(_objectSpread({}, this.props), this._panResponder.panHandlers));\n    }\n  }]);\n\n  return GestureRecognizer;\n}(Component);\n\nexport default GestureRecognizer;","map":{"version":3,"names":["React","Component","swipeDirections","SWIPE_UP","SWIPE_DOWN","SWIPE_LEFT","SWIPE_RIGHT","swipeConfig","velocityThreshold","directionalOffsetThreshold","gestureIsClickThreshold","isValidSwipe","velocity","directionalOffset","Math","abs","GestureRecognizer","props","context","config","responderEnd","_handlePanResponderEnd","bind","shouldSetResponder","_handleShouldSetPanResponder","_panResponder","PanResponder","create","onStartShouldSetPanResponder","onMoveShouldSetPanResponder","onPanResponderRelease","onPanResponderTerminate","prevProps","evt","gestureState","nativeEvent","touches","length","_gestureIsClick","dx","dy","swipeDirection","_getSwipeDirection","_triggerSwipeHandlers","onSwipe","onSwipeUp","onSwipeDown","onSwipeLeft","onSwipeRight","_isValidHorizontalSwipe","_isValidVerticalSwipe","vx","vy","panHandlers"],"sources":["/home/danilosilvadev/dev/@akalli/ak-icons/node_modules/react-native-swipe-gestures/index.js"],"sourcesContent":["\"use strict\";\n\nimport React, { Component } from \"react\";\nimport { View, PanResponder } from \"react-native\";\n\nexport const swipeDirections = {\n  SWIPE_UP: \"SWIPE_UP\",\n  SWIPE_DOWN: \"SWIPE_DOWN\",\n  SWIPE_LEFT: \"SWIPE_LEFT\",\n  SWIPE_RIGHT: \"SWIPE_RIGHT\"\n};\n\nconst swipeConfig = {\n  velocityThreshold: 0.3,\n  directionalOffsetThreshold: 80,\n  gestureIsClickThreshold: 5\n};\n\nfunction isValidSwipe(\n  velocity,\n  velocityThreshold,\n  directionalOffset,\n  directionalOffsetThreshold\n) {\n  return (\n    Math.abs(velocity) > velocityThreshold &&\n    Math.abs(directionalOffset) < directionalOffsetThreshold\n  );\n}\n\nclass GestureRecognizer extends Component {\n  constructor(props, context) {\n    super(props, context);\n    this.swipeConfig = Object.assign(swipeConfig, props.config);\n\n    const responderEnd = this._handlePanResponderEnd.bind(this);\n    const shouldSetResponder = this._handleShouldSetPanResponder.bind(this);\n    this._panResponder = PanResponder.create({\n      onStartShouldSetPanResponder: shouldSetResponder,\n      onMoveShouldSetPanResponder: shouldSetResponder,\n      onPanResponderRelease: responderEnd,\n      onPanResponderTerminate: responderEnd\n    });\n  }\n  \n  componentDidUpdate(prevProps) {\n    if (this.props.config !== prevProps.config) {\n      this.swipeConfig = Object.assign(swipeConfig, this.props.config);\n    }\n  }\n  \n  _handleShouldSetPanResponder(evt, gestureState) {\n    return (\n      evt.nativeEvent.touches.length === 1 &&\n      !this._gestureIsClick(gestureState)\n    );\n  }\n\n  _gestureIsClick(gestureState) {\n    return (\n      Math.abs(gestureState.dx) < swipeConfig.gestureIsClickThreshold &&\n      Math.abs(gestureState.dy) < swipeConfig.gestureIsClickThreshold\n    );\n  }\n\n  _handlePanResponderEnd(evt, gestureState) {\n    const swipeDirection = this._getSwipeDirection(gestureState);\n    this._triggerSwipeHandlers(swipeDirection, gestureState);\n  }\n\n  _triggerSwipeHandlers(swipeDirection, gestureState) {\n    const {\n      onSwipe,\n      onSwipeUp,\n      onSwipeDown,\n      onSwipeLeft,\n      onSwipeRight\n    } = this.props;\n    const { SWIPE_LEFT, SWIPE_RIGHT, SWIPE_UP, SWIPE_DOWN } = swipeDirections;\n    onSwipe && onSwipe(swipeDirection, gestureState);\n    switch (swipeDirection) {\n      case SWIPE_LEFT:\n        onSwipeLeft && onSwipeLeft(gestureState);\n        break;\n      case SWIPE_RIGHT:\n        onSwipeRight && onSwipeRight(gestureState);\n        break;\n      case SWIPE_UP:\n        onSwipeUp && onSwipeUp(gestureState);\n        break;\n      case SWIPE_DOWN:\n        onSwipeDown && onSwipeDown(gestureState);\n        break;\n    }\n  }\n\n  _getSwipeDirection(gestureState) {\n    const { SWIPE_LEFT, SWIPE_RIGHT, SWIPE_UP, SWIPE_DOWN } = swipeDirections;\n    const { dx, dy } = gestureState;\n    if (this._isValidHorizontalSwipe(gestureState)) {\n      return dx > 0 ? SWIPE_RIGHT : SWIPE_LEFT;\n    } else if (this._isValidVerticalSwipe(gestureState)) {\n      return dy > 0 ? SWIPE_DOWN : SWIPE_UP;\n    }\n    return null;\n  }\n\n  _isValidHorizontalSwipe(gestureState) {\n    const { vx, dy } = gestureState;\n    const { velocityThreshold, directionalOffsetThreshold } = this.swipeConfig;\n    return isValidSwipe(vx, velocityThreshold, dy, directionalOffsetThreshold);\n  }\n\n  _isValidVerticalSwipe(gestureState) {\n    const { vy, dx } = gestureState;\n    const { velocityThreshold, directionalOffsetThreshold } = this.swipeConfig;\n    return isValidSwipe(vy, velocityThreshold, dx, directionalOffsetThreshold);\n  }\n\n  render() {\n    return <View {...this.props} {...this._panResponder.panHandlers} />;\n  }\n}\n\nexport default GestureRecognizer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}