{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { useMenuTriggerState } from \"@react-stately/menu\";\nimport { useEffect, useMemo, useRef, useState } from \"react\";\nimport { useControlledState } from \"@react-stately/utils\";\nimport { ListCollection, useSingleSelectListState } from \"@react-stately/list\";\nimport _babelRuntimeHelpersEsmExtends from \"@babel/runtime/helpers/esm/extends\";\nexport function useComboBoxState(props) {\n  var _props$defaultInputVa, _props$items, _ref, _props$selectedKey;\n\n  var defaultFilter = props.defaultFilter,\n      _props$menuTrigger = props.menuTrigger,\n      menuTrigger = _props$menuTrigger === void 0 ? 'input' : _props$menuTrigger,\n      _props$allowsEmptyCol = props.allowsEmptyCollection,\n      allowsEmptyCollection = _props$allowsEmptyCol === void 0 ? false : _props$allowsEmptyCol,\n      allowsCustomValue = props.allowsCustomValue,\n      _props$shouldCloseOnB = props.shouldCloseOnBlur,\n      shouldCloseOnBlur = _props$shouldCloseOnB === void 0 ? true : _props$shouldCloseOnB;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      isFocused = _useState2[0],\n      setFocusedState = _useState2[1];\n\n  var _useControlledState = useControlledState(props.inputValue, (_props$defaultInputVa = props.defaultInputValue) != null ? _props$defaultInputVa : '', props.onInputChange),\n      _useControlledState2 = _slicedToArray(_useControlledState, 2),\n      inputValue = _useControlledState2[0],\n      setInputValue = _useControlledState2[1];\n\n  var onSelectionChange = function onSelectionChange(key) {\n    if (props.onSelectionChange) {\n      props.onSelectionChange(key);\n    }\n\n    if (props.isOpen === undefined || props.selectedKey === undefined) {\n      if (key === selectedKey) {\n        resetInputValue();\n        triggerState.close();\n      }\n    }\n  };\n\n  var _useSingleSelectListS = useSingleSelectListState(_babelRuntimeHelpersEsmExtends({}, props, {\n    onSelectionChange: onSelectionChange,\n    items: (_props$items = props.items) != null ? _props$items : props.defaultItems\n  })),\n      collection = _useSingleSelectListS.collection,\n      selectionManager = _useSingleSelectListS.selectionManager,\n      selectedKey = _useSingleSelectListS.selectedKey,\n      setSelectedKey = _useSingleSelectListS.setSelectedKey,\n      selectedItem = _useSingleSelectListS.selectedItem,\n      disabledKeys = _useSingleSelectListS.disabledKeys;\n\n  var filteredCollection = useMemo(function () {\n    return props.items != null || !defaultFilter ? collection : $b1b6afed698df4428b7ed319af4b90$var$filterCollection(collection, inputValue, defaultFilter);\n  }, [collection, inputValue, defaultFilter, props.items]);\n  var triggerState = useMenuTriggerState(props);\n\n  var open = function open(focusStrategy) {\n    if (allowsEmptyCollection || filteredCollection.size > 0) {\n      triggerState.open(focusStrategy);\n    }\n  };\n\n  var toggle = function toggle(focusStrategy) {\n    if (!(allowsEmptyCollection || filteredCollection.size > 0) && !triggerState.isOpen) {\n      return;\n    }\n\n    triggerState.toggle(focusStrategy);\n  };\n\n  var lastValue = useRef(inputValue);\n\n  var resetInputValue = function resetInputValue() {\n    var _collection$getItem$t, _collection$getItem;\n\n    var itemText = (_collection$getItem$t = (_collection$getItem = collection.getItem(selectedKey)) == null ? void 0 : _collection$getItem.textValue) != null ? _collection$getItem$t : '';\n    lastValue.current = itemText;\n    setInputValue(itemText);\n  };\n\n  var isInitialRender = useRef(true);\n  var lastSelectedKey = useRef((_ref = (_props$selectedKey = props.selectedKey) != null ? _props$selectedKey : props.defaultSelectedKey) != null ? _ref : null);\n  useEffect(function () {\n    if (isFocused && filteredCollection.size > 0 && !triggerState.isOpen && inputValue !== lastValue.current && menuTrigger !== 'manual' && (props.isOpen === undefined || props.inputValue === undefined)) {\n      open();\n    }\n\n    if (!allowsEmptyCollection && triggerState.isOpen && filteredCollection.size === 0 && (props.isOpen === undefined || props.items === undefined)) {\n      triggerState.close();\n    }\n\n    if (selectedKey != null && selectedKey !== lastSelectedKey.current && (props.isOpen === undefined || props.selectedKey === undefined)) {\n      triggerState.close();\n    }\n\n    if (inputValue !== lastValue.current) {\n      selectionManager.setFocusedKey(null);\n\n      if (inputValue === '' && (props.inputValue === undefined || props.selectedKey === undefined)) {\n        setSelectedKey(null);\n      }\n    }\n\n    if (isInitialRender.current && props.inputValue === undefined && props.defaultInputValue === undefined) {\n      resetInputValue();\n    }\n\n    if (selectedKey !== lastSelectedKey.current && (props.inputValue === undefined || props.selectedKey === undefined)) {\n      resetInputValue();\n    } else {\n      lastValue.current = inputValue;\n    }\n\n    isInitialRender.current = false;\n    lastSelectedKey.current = selectedKey;\n  });\n  useEffect(function () {\n    if (!triggerState.isOpen) {\n      selectionManager.setFocusedKey(null);\n    }\n  }, [triggerState.isOpen, selectionManager]);\n\n  var commitCustomValue = function commitCustomValue() {\n    var shouldClose = false;\n    lastSelectedKey.current = null;\n    setSelectedKey(null);\n\n    if (selectedKey === null && props.onSelectionChange) {\n      props.onSelectionChange(null);\n    }\n\n    shouldClose = props.isOpen == null || props.selectedKey === undefined;\n\n    if (shouldClose) {\n      triggerState.close();\n    }\n  };\n\n  var commit = function commit() {\n    if (triggerState.isOpen && selectionManager.focusedKey != null) {\n      if (selectedKey === selectionManager.focusedKey) {\n        resetInputValue();\n        triggerState.close();\n      } else {\n        setSelectedKey(selectionManager.focusedKey);\n      }\n    } else if (allowsCustomValue) {\n      commitCustomValue();\n    }\n  };\n\n  var setFocused = function setFocused(isFocused) {\n    if (isFocused) {\n      if (menuTrigger === 'focus') {\n        open();\n      }\n    } else if (shouldCloseOnBlur) {\n      var _collection$getItem$t2, _collection$getItem2;\n\n      var itemText = (_collection$getItem$t2 = (_collection$getItem2 = collection.getItem(selectedKey)) == null ? void 0 : _collection$getItem2.textValue) != null ? _collection$getItem$t2 : '';\n\n      if (allowsCustomValue && inputValue !== itemText) {\n        commitCustomValue();\n      } else {\n        resetInputValue();\n        triggerState.close();\n      }\n    }\n\n    setFocusedState(isFocused);\n  };\n\n  return _babelRuntimeHelpersEsmExtends({}, triggerState, {\n    toggle: toggle,\n    open: open,\n    selectionManager: selectionManager,\n    selectedKey: selectedKey,\n    setSelectedKey: setSelectedKey,\n    disabledKeys: disabledKeys,\n    isFocused: isFocused,\n    setFocused: setFocused,\n    selectedItem: selectedItem,\n    collection: filteredCollection,\n    inputValue: inputValue,\n    setInputValue: setInputValue,\n    commit: commit\n  });\n}\n\nfunction $b1b6afed698df4428b7ed319af4b90$var$filterCollection(collection, inputValue, filter) {\n  return new ListCollection($b1b6afed698df4428b7ed319af4b90$var$filterNodes(collection, inputValue, filter));\n}\n\nfunction $b1b6afed698df4428b7ed319af4b90$var$filterNodes(nodes, inputValue, filter) {\n  var filteredNode = [];\n\n  for (var _iterator = _createForOfIteratorHelperLoose(nodes), _step; !(_step = _iterator()).done;) {\n    var node = _step.value;\n\n    if (node.type === 'section' && node.hasChildNodes) {\n      var filtered = $b1b6afed698df4428b7ed319af4b90$var$filterNodes(node.childNodes, inputValue, filter);\n\n      if (_toConsumableArray(filtered).length > 0) {\n        filteredNode.push(_babelRuntimeHelpersEsmExtends({}, node, {\n          childNodes: filtered\n        }));\n      }\n    } else if (node.type !== 'section' && filter(node.textValue, inputValue)) {\n      filteredNode.push(node);\n    }\n  }\n\n  return filteredNode;\n}","map":{"version":3,"sources":["packages/@react-stately/combobox/src/useComboBoxState.ts"],"names":["menuTrigger","allowsEmptyCollection","shouldCloseOnBlur","useState","useControlledState","props","onSelectionChange","key","resetInputValue","triggerState","disabledKeys","useSingleSelectListState","items","defaultItems","filteredCollection","useMemo","filterCollection","useMenuTriggerState","open","focusStrategy","toggle","lastValue","useRef","itemText","collection","setInputValue","isInitialRender","lastSelectedKey","useEffect","isFocused","inputValue","selectedKey","selectionManager","setSelectedKey","commitCustomValue","shouldClose","commit","setFocused","allowsCustomValue","setFocusedState","selectedItem","filterNodes","filteredNode","node","filtered","childNodes","filter"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, FocusStrategy, Node} from '@react-types/shared';\nimport {ComboBoxProps} from '@react-types/combobox';\nimport {ListCollection, useSingleSelectListState} from '@react-stately/list';\nimport {SelectState} from '@react-stately/select';\nimport {useControlledState} from '@react-stately/utils';\nimport {useEffect, useMemo, useRef, useState} from 'react';\nimport {useMenuTriggerState} from '@react-stately/menu';\n\nexport interface ComboBoxState<T> extends SelectState<T> {\n  /** The current value of the combo box input. */\n  inputValue: string,\n  /** Sets the value of the combo box input. */\n  setInputValue(value: string): void,\n  /** Selects the currently focused item and updates the input value. */\n  commit(): void\n}\n\ntype FilterFn = (textValue: string, inputValue: string) => boolean;\ninterface ComboBoxStateProps<T> extends ComboBoxProps<T> {\n  /** The filter function used to determine if a option should be included in the combo box list. */\n  defaultFilter?: FilterFn,\n  /** Whether the combo box allows the menu to be open when the collection is empty. */\n  allowsEmptyCollection?: boolean,\n  /** Whether the combo box menu should close on blur. */\n  shouldCloseOnBlur?: boolean\n}\n\n/**\n * Provides state management for a combo box component. Handles building a collection\n * of items from props and manages the option selection state of the combo box. In addition, it tracks the input value,\n * focus state, and other properties of the combo box.\n */\nexport function useComboBoxState<T extends object>(props: ComboBoxStateProps<T>): ComboBoxState<T> {\n  let {\n    defaultFilter,\n    menuTrigger = 'input',\n    allowsEmptyCollection = false,\n    allowsCustomValue,\n    shouldCloseOnBlur = true\n  } = props;\n\n  let [isFocused, setFocusedState] = useState(false);\n  let [inputValue, setInputValue] = useControlledState(\n    props.inputValue,\n    props.defaultInputValue ?? '',\n    props.onInputChange\n  );\n\n  let onSelectionChange = (key) => {\n    if (props.onSelectionChange) {\n      props.onSelectionChange(key);\n    }\n\n    // If open state or selectedKey is uncontrolled and key is the same, reset the inputValue and close the menu\n    // (scenario: user clicks on already selected option)\n    if (props.isOpen === undefined || props.selectedKey === undefined) {\n      if (key === selectedKey) {\n        resetInputValue();\n        triggerState.close();\n      }\n    }\n  };\n\n  let {collection, selectionManager, selectedKey, setSelectedKey, selectedItem, disabledKeys} = useSingleSelectListState({\n    ...props,\n    onSelectionChange,\n    items: props.items ?? props.defaultItems\n  });\n\n  let filteredCollection = useMemo(() => (\n    // No default filter if items are controlled.\n    props.items != null || !defaultFilter\n      ? collection\n      : filterCollection(collection, inputValue, defaultFilter)\n  ), [collection, inputValue, defaultFilter, props.items]);\n\n  let triggerState = useMenuTriggerState(props);\n  let open = (focusStrategy?: FocusStrategy) => {\n    // Prevent open operations from triggering if there is nothing to display\n    if (allowsEmptyCollection || filteredCollection.size > 0) {\n      triggerState.open(focusStrategy);\n    }\n  };\n\n  let toggle = (focusStrategy?: FocusStrategy) => {\n    // If the menu is closed and there is nothing to display, early return so toggle isn't called to prevent extraneous onOpenChange\n    if (!(allowsEmptyCollection || filteredCollection.size > 0) && !triggerState.isOpen) {\n      return;\n    }\n\n    triggerState.toggle(focusStrategy);\n  };\n\n  let lastValue = useRef(inputValue);\n  let resetInputValue = () => {\n    let itemText = collection.getItem(selectedKey)?.textValue ?? '';\n    lastValue.current = itemText;\n    setInputValue(itemText);\n  };\n\n  let isInitialRender = useRef(true);\n  let lastSelectedKey = useRef(props.selectedKey ?? props.defaultSelectedKey ?? null);\n  useEffect(() => {\n    // If open state or inputValue is uncontrolled, open and close automatically when the input value changes,\n    // the input is if focused, and there are items in the collection.\n    if (\n      isFocused &&\n      filteredCollection.size > 0 &&\n      !triggerState.isOpen &&\n      inputValue !== lastValue.current &&\n      menuTrigger !== 'manual' &&\n      (props.isOpen === undefined || props.inputValue === undefined)\n    ) {\n      open();\n    }\n\n    // Close the menu if the collection is empty and either open state or items are uncontrolled.\n    if (\n      !allowsEmptyCollection &&\n      triggerState.isOpen &&\n      filteredCollection.size === 0 &&\n      (props.isOpen === undefined || props.items === undefined)\n    ) {\n      triggerState.close();\n    }\n\n    // Close when an item is selected, if open state or selectedKey is uncontrolled.\n    if (\n      selectedKey != null &&\n      selectedKey !== lastSelectedKey.current &&\n      (props.isOpen === undefined || props.selectedKey === undefined)\n    ) {\n      triggerState.close();\n    }\n\n    // Clear focused key when input value changes.\n    if (inputValue !== lastValue.current) {\n      selectionManager.setFocusedKey(null);\n\n      // Set selectedKey to null when the user clears the input.\n      // If controlled, this is the application developer's responsibility.\n      if (inputValue === '' && (props.inputValue === undefined || props.selectedKey === undefined)) {\n        setSelectedKey(null);\n      }\n    }\n\n    // If it is the intial render and inputValue isn't controlled nor has an intial value, set input to match current selected key if any\n    if (isInitialRender.current && (props.inputValue === undefined && props.defaultInputValue === undefined)) {\n      resetInputValue();\n    }\n\n    // If the selectedKey changed, update the input value.\n    // Do nothing if both inputValue and selectedKey are controlled.\n    // In this case, it's the user's responsibility to update inputValue in onSelectionChange. In addition, we preserve the defaultInputValue\n    // on initial render, even if it doesn't match the selected item's text.\n    if (\n      selectedKey !== lastSelectedKey.current &&\n      (props.inputValue === undefined || props.selectedKey === undefined)\n    ) {\n      resetInputValue();\n    } else {\n      lastValue.current = inputValue;\n    }\n\n    isInitialRender.current = false;\n    lastSelectedKey.current = selectedKey;\n  });\n\n  useEffect(() => {\n    // Reset focused key when the menu closes\n    if (!triggerState.isOpen) {\n      selectionManager.setFocusedKey(null);\n    }\n  }, [triggerState.isOpen, selectionManager]);\n\n  let commitCustomValue = () => {\n    let shouldClose = false;\n    lastSelectedKey.current = null;\n    setSelectedKey(null);\n\n    // If previous key was already null, need to manually call onSelectionChange since it won't be triggered by a setSelectedKey call\n    // This allows the application to control whether or not to close the menu on custom value commit\n    if (selectedKey === null && props.onSelectionChange) {\n      props.onSelectionChange(null);\n    }\n\n    // Should close menu ourselves if component open state or selected key is uncontrolled and therefore won't be closed by a user defined event handler\n    shouldClose = props.isOpen == null || props.selectedKey === undefined;\n\n\n    // Close if no other event will be fired. Otherwise, allow the\n    // application to control this based on that event.\n    if (shouldClose) {\n      triggerState.close();\n    }\n  };\n\n  let commit = () => {\n    if (triggerState.isOpen && selectionManager.focusedKey != null) {\n      // Reset inputValue and close menu here if the selected key is already the focused key. Otherwise\n      // fire onSelectionChange to allow the application to control the closing.\n      if (selectedKey === selectionManager.focusedKey) {\n        resetInputValue();\n        triggerState.close();\n      } else {\n        setSelectedKey(selectionManager.focusedKey);\n      }\n    } else if (allowsCustomValue) {\n      commitCustomValue();\n    }\n  };\n\n  let setFocused = (isFocused: boolean) => {\n    if (isFocused) {\n      if (menuTrigger === 'focus') {\n        open();\n      }\n    } else if (shouldCloseOnBlur) {\n      let itemText = collection.getItem(selectedKey)?.textValue ?? '';\n      if (allowsCustomValue && inputValue !== itemText) {\n        commitCustomValue();\n      } else {\n        resetInputValue();\n        // Close menu if blurring away from the combobox\n        // Specifically handles case where user clicks away from the field\n        triggerState.close();\n      }\n    }\n\n    setFocusedState(isFocused);\n  };\n\n  return {\n    ...triggerState,\n    toggle,\n    open,\n    selectionManager,\n    selectedKey,\n    setSelectedKey,\n    disabledKeys,\n    isFocused,\n    setFocused,\n    selectedItem,\n    collection: filteredCollection,\n    inputValue,\n    setInputValue,\n    commit\n  };\n}\n\nfunction filterCollection<T extends object>(collection: Collection<Node<T>>, inputValue: string, filter: FilterFn): Collection<Node<T>> {\n  return new ListCollection(filterNodes(collection, inputValue, filter));\n}\n\nfunction filterNodes<T>(nodes: Iterable<Node<T>>, inputValue: string, filter: FilterFn): Iterable<Node<T>> {\n  let filteredNode = [];\n  for (let node of nodes) {\n    if (node.type === 'section' && node.hasChildNodes) {\n      let filtered = filterNodes(node.childNodes, inputValue, filter);\n      if ([...filtered].length > 0) {\n        filteredNode.push({...node, childNodes: filtered});\n      }\n    } else if (node.type !== 'section' && filter(node.textValue, inputValue)) {\n      filteredNode.push(node);\n    }\n  }\n  return filteredNode;\n}\n"]},"metadata":{},"sourceType":"module"}